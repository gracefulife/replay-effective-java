# 객체의 생성과 삭제.

## 1.
생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보라.  
* 정적 팩토리 메소드는 이름이 있기 때문에, 가독성을 높일 수 있음.  
* 객체 생성 전략을 선택할 수 있다.
* 하위 자료형을 반환할 수 있다.
  * 이는 컬렉션 프레임워크를 보면 알 수 있다. 
  * 외부에 노출하지 않은 클래스의 인스턴스를 돌려줄 수 있다. (노출된 상위 타입으로)
  * guava 가 생각났는데, 구아바는 구체 클래스를 리턴하는군 .. (Lists.newArrayList 같은 것.)
* 제네릭의 타입을 생성 시 추론할 수 있다는게 장점이라고 써져있지만, 이는 1.7 때 추가 된 피쳐

그러나
* public 또는 protected 생성자 없이 하위 클래스를 만들 수 없다는 점.
  * % 하지만 나의 경우 실제로 개발을 하다보면 다른 Third-party 의 reflection 을 통한 객체 접근에서 에러가 발생하는 문제 때문에 디폴트 생성자는 사용하지 않더라도 그냥 열어놓는 편이기 때문에 .. 이런 경우 그냥 해결되는 문제긴 하다.


## 2. 
빌더 패턴 적용을 고려하라.

* 생성자가 많아지게 되는 경우, 복잡해지고 읽기 어려운 코드를 만들게 되는 것을 느끼게 된다.
* 이런때 빌더 패턴 적용을 한다면 다양한 장점을 누릴 수 있다.

하지만 나는 빌더를 사용하지 않으므로, 자세히 서술하지는 않는다.  
사용하지 않는 이유는 아래와 같다.
* % 빌더를 사용하면 필드 추가 등의 동작에서 문법 오류를 정확히 나타내기 힘들다.
* % 문법오류가 나지 않아도, 직접 주의해서 찾아서 수정해줄 수 있지만   
정적 생성자를 만들고, 아에 코드가 컴파일 되지 않는 상황에서 찾는 것보다 훨씬 어렵고,  
 오래걸린다고 생각한다. 
* % 가독성이 향상된다고 생각하지 않는다. 빌더패턴은 요상하게 사람의 눈이 코드를 그냥 생각없이 읽고 넘어가게 만드는 효과가 있다고 생각한다.

## 3. 
private, enum 자료형은 싱글턴 패턴을 따르도록 설계하라.

이 내용은 자세히 읽지 않았다. 

% 그냥 싱글턴 패턴을 사용하지 않도록 한다.  
싱글턴 패턴은 사용되는 프레임워크에서 제공해줄 수 있는 방법으로 사용하도록 하자.  
안드로이드라면 Application, 스프링이라면 Spring bean 으로.  

* 혹시라도 싱글턴을 사용한다면 enum 을 사용한다.
* 단일 인스턴스를 보장하고, 다양한 경우를 신경쓰지 않아도 동기화까지 보장되는 유일한 방법이다.

## 4.
객체 생성을 막을때는 private 생성자를 사용한다.  
연산의 멱등이 보장되는 = 유틸리티 클래스 들은 객체를 만들 목적의 클래스가 아니다.

%
개인적으로는 유틸리티 클래스는 abstract 클래스로 만들고, 메소드를 static final 로 설정한다.  
그렇다면 상속을 한다 하여도, 어차피 해당 메소드들은 확장할 수 없다.  
private 생성자로 만드는 것보다 더 직관적이라고 생각한다.   
또 이는 Spring 유틸리티 클래스들에 적용되는 규칙이기도 하다.

## 5. 
불필요한 객체는 만들지 말라.  

다양한 경우 생길 수 있는 문제인데, 생성 비용이 높은 객체를  
반복문 내에서 만든다던가, 스트링을 new String() 형식으로 생성한다던가 하는 것 들이다.  

% 그러나, 반복문 내에서 생성비용이 높은 객체를 생성하는 등 .. 의 내용은 지금에 와서는 별 의미가 없는 내용이 아닐까 생각해본다.   
사소한 수준의 최적화보다는, 명확한 코드 블럭의 표현이 더 중요한 시대가 아닌가 생각해본다.

## 6. 
유효기간이 지난 객체 참조는 폐기하라.  

null 로 명시적 assign 이 필요한 경우가 간헐적으로 있을 수 있다.  
일반적으로 메모리를 직접 관리하는 경우 메모리의 반환에 주의하여야 한다.  
흔히 캐시에서 발생한다. 캐시를 WeakHashMap 을 가지고 구현하면 이러한 문제를 해결할 수 있다.  

%캐시에 관해 나름 [재미있는 경험](http://gracefulife.xyz/221253732171)이 있다.

## 7.
종료자 사용을 피하라.

종료자는 예측 불가능하고, 위험하고, 일반적으로 불필요하다.  
큰 문제는, 즉시 실행되리라는 보장이 없다는 것이다.

종료자 실행 시점은 가비지컬렉션 알고리즘에 의해 좌우된다.  
JVM 환경에 따라 동작이 변경된다는 것은 예측하지 못한 문제를 발생시킨다.

만약 꼭 사용해야 한다면 종료 보호자 등의 기법을 활용하자.

% 그러나 나와 같은 응용프로그래머들은 직접 사용할일이 없을 것 같다.  
종료 시 해주어야 하는 작업이 있다면, 사용되는 프레임워크의   
shut-down hook 정도를 활용할 수 있도록 하면 좋겠다.